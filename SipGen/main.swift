//
//  main.swift
//  SipGen
//
//  Created by Cao Viet Dung on 2018/11/13.
//  Copyright Â© 2018 Cao Viet Dung. All rights reserved.
//

import Foundation

let maxArity = 10
let dateFormatter = DateFormatter()
dateFormatter.dateFormat = "yyyy/MM/dd"
let generatedDate = dateFormatter.string(from: Date())
let debugArgs = "file: StaticString=#file, line: Int=#line, function: StaticString=#function"

func generateHeader(ofFile path: URL) -> String {
    return """
    //
    //  \(path.lastPathComponent)
    //  Sip
    //
    //  Generated by SipGen/main.swift on \(generatedDate).
    //  DO NOT EDIT
    //
    """
}

func generateBinderHelper(toFile path: URL) throws {
    let content = """
    \(generateHeader(ofFile: path))

    public extension BinderProtocol {
    \((1...maxArity).map { generateBinderFunc(arity: $0) }.joined(separator: "\n"))
    }
    """
    try content.write(to: path, atomically: true, encoding: .utf8)
}

func generateProvider(arity: Int) -> String {
    return (1...arity).map {
        "            let p\($0): Provider<T\($0)> = p.provider()"
        }.joined(separator: "\n")
}

func generateBinderFunc(arity: Int) -> String {
    let arityTypes = (1...arity).map { "T\($0)" }.joined(separator: ", ")

    let content = """

        // \(arity)-arity `to(factory:)` function.
        public func to<\(arityTypes)>(\(debugArgs), factory: @escaping ((\(arityTypes))) -> Element) {
            to(file: file, line: line, function: function, creator: { p -> Provider<Element> in
    \(generateProvider(arity: arity))

                return Provider {
                    factory((\((1...arity).map { "p\($0).get()" }.joined(separator: ", "))))
                }
            })
        }
    """

    return content
}

func generateInjectorHelper(toFile path: URL) throws {
    let content = """
    \(generateHeader(ofFile: path))

    public extension BinderProtocol where Element: InjectorProtocol {
        typealias InjectionHost = Element.Element
    \((1...maxArity).map { generateInjectorFunc(arity: $0) }.joined(separator: "\n"))
    }
    """
    try content.write(to: path, atomically: true, encoding: .utf8)
}

func generateInjectorFunc(arity: Int) -> String {
    let arityTypes = (1...arity).map { "T\($0)" }.joined(separator: ", ")

    let content = """

        // \(arity)-arity `to(injector:)` function.
        public func to<\(arityTypes)>(\(debugArgs), injector: @escaping (InjectionHost) -> (\(arityTypes)) -> Void) {
            to(file: file, line: line, function: function, creator: { p -> Provider<Element> in
    \(generateProvider(arity: arity))

                return Provider {
                    Element { host in
                        injector(host)(\((1...arity).map { "p\($0).get()" }.joined(separator: ", ")))
                    }
                }
            })
        }
    """

    return content
}

func generateAssistedInjectionHelper(toFile path: URL) throws {
    let content = """
    \(generateHeader(ofFile: path))

    public extension BinderProtocol where Element: AssistedInjectionFactoryProtocol {
        typealias Argument = Element.Argument
        typealias Output = Element.Element
    \((1...maxArity).map { generateAssistedInjectionFunc(arity: $0) }.joined(separator: "\n"))
    }
    """

    try content.write(to: path, atomically: true, encoding: .utf8)
}

func generateAssistedInjectionFunc(arity: Int) -> String {
    let arityTypes = (1...arity).map { "T\($0)" }.joined(separator: ", ")

    let content = """

        // \(arity)-arity `to(elementFactory:)` function.
        public func to<\(arityTypes)>(\(debugArgs), elementFactory: @escaping (\(arityTypes), Argument) -> Output) {
            to(file: file, line: line, function: function, creator: { p -> Provider<Element> in
    \(generateProvider(arity: arity))

                return Provider {
                    Element { argument in
                        elementFactory(\((1...arity).map { "p\($0).get()" }.joined(separator: ", ")), argument)
                    }
                }
            })
        }
    """

    return content
}

let libraryPath = URL(fileURLWithPath: #file)
    .deletingLastPathComponent()
    .deletingLastPathComponent()
    .appendingPathComponent("Sip")
    .appendingPathComponent("Generated")
do {
    try generateBinderHelper(toFile: libraryPath.appendingPathComponent("BinderHelper.swift"))
    try generateInjectorHelper(toFile: libraryPath.appendingPathComponent("InjectorHelper.swift"))
    try generateAssistedInjectionHelper(toFile: libraryPath.appendingPathComponent("AssistedInjectionHelper.swift"))
} catch (let e) {
    print("Something happened: \(e)")
}
