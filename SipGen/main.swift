//
//  main.swift
//  SipGen
//
//  Created by Cao Viet Dung on 2018/11/13.
//  Copyright Â© 2018 Cao Viet Dung. All rights reserved.
//

import Foundation

let maxArity = 10
let dateFormatter = DateFormatter()
dateFormatter.dateFormat = "yyyy/MM/dd"
let generatedDate = dateFormatter.string(from: Date())


func generateBinderHelper(toFile path: URL) throws {
    let content = """
    //
    //  BinderHelper.swift
    //  Sip
    //
    //  Generated by SipGen/main.swift on \(generatedDate).
    //  DO NOT EDIT
    //

    public extension BinderProtocol {
    \((1...maxArity).map { generateBinderFunc(arity: $0) }.joined(separator: "\n"))
    }
    """
    try content.write(to: path, atomically: true, encoding: .utf8)
}

func generateProvider(arity: Int) -> String {
    return (1...arity).map {
        "            let p\($0): Provider<T\($0)> = p.provider()"
        }.joined(separator: "\n")
}

func generateBinderFunc(arity: Int) -> String {
    let debugArgs = "file: StaticString=#file, line: Int=#line, function: StaticString=#function"
    let arityTypes = (1...arity).map { "T\($0)" }.joined(separator: ", ")
    
    let content = """
    
        // \(arity)-arity `to(factory:)` function.
        public func to<\(arityTypes)>(\(debugArgs), factory: @escaping ((\(arityTypes))) -> Element) {
            return to(file: file, line: line, function: function) { p in
    \(generateProvider(arity: arity))

                return Provider {
                    factory((\((1...arity).map { "p\($0).get()" }.joined(separator: ", "))))
                }
            }
        }
    """
   
    return content
}

func generateInjectorHelper(toFile path: URL) throws {
    let content = """
    //
    //  InjectorHelper.swift
    //  Sip
    //
    //  Generated by SipGen/main.swift on \(generatedDate).
    //  DO NOT EDIT
    //
    
    public extension BinderProtocol where Element: InjectorProtocol {
        typealias InjectionHost = Element.Element
    \((1...maxArity).map { generateInjectorFunc(arity: $0) }.joined(separator: "\n"))
    }
    """
    try content.write(to: path, atomically: true, encoding: .utf8)
}

func generateInjectorFunc(arity: Int) -> String {
    let debugArgs = "file: StaticString=#file, line: Int=#line, function: StaticString=#function"
    let arityTypes = (1...arity).map { "T\($0)" }.joined(separator: ", ")
    
    let content = """
    
        // \(arity)-arity `to(injector:)` function.
        public func to<\(arityTypes)>(\(debugArgs), injector: @escaping (InjectionHost) -> (\(arityTypes)) -> Void) {
            return to(file: file, line: line, function: function) { p in
    \(generateProvider(arity: arity))
    
                return Provider {
                    Element.init { host in
                        injector(host)(\((1...arity).map { "p\($0).get()" }.joined(separator: ", ")))
                    }
                }
            }
        }
    """
    
    return content
}

let libraryPath = URL(fileURLWithPath: #file)
    .deletingLastPathComponent()
    .deletingLastPathComponent()
    .appendingPathComponent("Sip")
    .appendingPathComponent("Generated")
do {
    try generateBinderHelper(toFile: libraryPath.appendingPathComponent("BinderHelper.swift"))
    try generateInjectorHelper(toFile: libraryPath.appendingPathComponent("InjectorHelper.swift"))
} catch (let e) {
    print("Something happened: \(e)")
}
